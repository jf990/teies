/*+-------------------------------------------------------------------+
     <DOC>
     <NAME>    lk_ntf
     <AUTHOR>  Tanmay S. Kumar
     <DATE>    October 19, 1988
     <LEVEL>   OBJ
     <PARAM>   notif_ocb   OCB *      INPUT  OCB of the Notification
                                              or Root object to attach
                                              notif to.
     <PARAM>   modifier    string     INPUT  Packet of OCD's that are
                                              modified for reiterative
                                              calls from cr_notif().
                                             For AUTOMATIC notifs
                                             this param has the names
                                             of the people to send to.

     <PARAM>   level       hword      INPUT  This shows whether the
                                             Notification is of INTER-
                                             ACTIVE OR AUTOMATIC type

     <PARAM>   result_str  byte  **   INOUT  Pointer to a string where
                                              error messages and other
                                              communicated data will
                                              go.

     <PURPOSE> Link the new notification object to the following
                 1) Authors Old Notification index
                 2) Recipients New Notification index
                 3) New Notif count for Recipients
                 4) Old Notif count for Author
                 5) Next notif id for Author and Recipients
               If the level is INTERACTIVE we call ntf_valto() to do the
               verifications. If it is an AUTOMATIC notification type
               then lk_ntf..() is called to do the verification.

               If this server is not the Master Server then the object
               is sent to the Master Server for linking.  The MS will
               send back the entire notif object when done. If errors
               occur the confirmation packet will contain the error
               code and any resulting data string to report to the
               user.

     <OUTPUT>  sint      result code either generated by this routine
                         locally or remotely.
     </DOC>
  +-------------------------------------------------------------------+*/
#include "defs.h"
#include "str.h"
#include "osk.h"
#include "debug.h"
#include "obj.h"
#include "tm.h"
#include "vars.h"
#include "exc.h"
#include "obj_prim.h"


sint     lk_ntf( notif_ocb, modifier, level, result_str )

OCB              *  notif_ocb;
string              modifier;
hword               level;
byte             ** result_str;

{

 sint   rc                =        0,
        num_of_recip      =        0,
        i                 =        0,
        notif_id          =        0,
        old_notif_count   =        0,
        notif_key_length  =        0;

 hword  flags             =        0;

 string *result           =    NIL,
        next_notif_id     = S_NULL;

 OCB    *list_ocb         =    NIL,
        *author_ocb       =    NIL,
        *object           =    NIL,
        *recipient_ocb    =    NIL;

 OCD    *recipient_ocd    =    NIL,
        *list_ocd         =    NIL,
        *author_ocd       =    NIL;

 OID                    author_oid,
                     recipient_oid;

 boolean   ok_to_link     =   FALSE,
           passed         =   FALSE,
           exists         =   FALSE;



 if (TM_master->usrtype == MASTER_SERVER )
 {
              /* - - - - - - - - - - - - - - - - - - - - - -*
               |   The first step is to validate all the    |
               |   intended recipients.  Use s_parse() to   |
               |   get each name from the string of names   |
               |   entered by the user.  Then find these    |
               |   users in the database.  All users not    |
               |   found are collected together.  If there  |
               |   are unknown users then put this process  |
               |   on hold by keeping the object here and   |
               |   wait for the user server to either send  |
               |   updates or request the process be canned.|
               + - - - - - - - - - - - - - - - - - - - - - -*/

    ocd_new( & list_ocd, "LIST.SIZE" );

    if ((level == 0) || (level == INTERACTIVE_CREATION))
    {
       list_ocb = obj_all(LIST_OBJ, LOCAL_OBJECT, NIL);
       rc = ntf_valto( notif_ocb, list_ocb, & author_oid, & num_of_recip,
                                                   (string *)result_str);
    }
    else if (level == AUTOMATIC_CREATION)
    {
       switch ( notif_ocb->type )
       {
          case MAIL_OBJ :
          case ACT_OBJ  :
                         list_ocb = obj_all(LIST_OBJ, LOCAL_OBJECT, NIL);
                         object = notif_ocb;
                         rc = ntf_auto( object, list_ocb, &author_oid,
                                    &notif_ocb, &num_of_recip, modifier);
                         break;
          case CC_OBJ   :
                         break;
          case GROUP_OBJ:
                         break;
          case USER_OBJ :
                         break;
          case CONF_OBJ :
                         break;
          case MEMB_OBJ :

                         list_ocb = (OCB *) (*result_str);
                         passed   = TRUE;
                         object   = notif_ocb;
                         rc = ntf_memb( object, modifier, & author_oid,
                                                          & notif_ocb);
                         rc = obj_get(list_ocb, list_ocd, &num_of_recip);


                         break;
          default       :
                         break;
       }
    }
    else
    {
       rc = OBJ_LEVEL_UNSUPPORTED;
    }

    if (rc == 0)
    {
       /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        * Set a new Notification ID for the receipients and author  *
        * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


       author_ocb = obj_opn( & author_oid, OBJ_UPDATE );
       ocd_new( & recipient_ocd, "INDEXES.NEXT_NOTIF_ID" );
       notif_key_length = ocd_len( author_ocb, recipient_ocd );
       if( notif_key_length < 1 || notif_key_length > 16 )
       {

          notif_key_length = NTF_KEY_LENGTH;

       }
       ocd_new( & list_ocd, "LIST.LIST.OID" );
       list_ocd->bias = 1;

       for (  i = 1;  i <= num_of_recip;  i++  )
       {

          rc = obj_get( list_ocb, list_ocd, & recipient_oid );
          if (rc == 0)
          {

             if ( oid_cmp(author_oid, recipient_oid) )
             {
                exists = TRUE;
             }

             recipient_ocb = obj_opn( & recipient_oid, OBJ_UPDATE );

             if (OCB_POINTER_OK( recipient_ocb ) )
             {

                rc = obj_alk ( notif_ocb,      "ACCESS",
                                       recipient_ocb, RECIPIENT_LINK );

                s_init( &(recipient_ocd->name), "INDEXES.NEXT_NOTIF_ID");
                rc = obj_get( recipient_ocb, recipient_ocd,
                                                       & next_notif_id );
                s_stosi( & notif_id, next_notif_id, 0, 0 );

                if (notif_id < NTF_MIN_NOTIF_ID )
                {
                   notif_id = NTF_MIN_NOTIF_ID;
                }
                notif_id++;
                if( notif_id > NTF_MAX_NOTIF_ID )
                {

                   notif_id = NTF_MIN_NOTIF_ID + 1;

                }
                s_sitos( & next_notif_id, notif_id );
                rc = obj_rep(recipient_ocb, recipient_ocd, next_notif_id,
                                                             SEG_UPDATE);
                notif_id--;
                s_sitos( & next_notif_id, notif_id );
                s_pad(  & next_notif_id, next_notif_id, notif_key_length,
                                                               ' ', 'L');

               /********************************************************/
               /* adding the notification.label into by setting the key*/
               /* for recipient_ocd->key, and adding notificat.oid by  */
               /* setting the recipient_ocd->name                      */
               /********************************************************/

                rc = add_to_user_list( recipient_ocb,
                                       "INDEXES.NOTIFICATIONS",
                                       next_notif_id, & (notif_ocb->oid),
                                       0, S_NULL                       );

                obj_cls( recipient_ocb );

             }   /* end of if ocb pointer ok */
             else
             {
             }
          }
          else
          {
          }
       }    /* end for loop */
       ocd_drp( & recipient_ocd);
       ocd_drp( & list_ocd);


       if ( OCB_POINTER_OK( author_ocb ) )
       {

          ocd_new( & author_ocd, "INDEXES.NEXT_NOTIF_ID" );
          rc = obj_get(author_ocb, author_ocd, &next_notif_id);
          s_stosi(&notif_id, next_notif_id, 0, 0);

          if (notif_id < NTF_MIN_NOTIF_ID )
          {
             notif_id = NTF_MIN_NOTIF_ID;
          }

          if (!exists)          /* author is not in recipient list    */
          {                     /* hence index it under next notif id */
             notif_id++;
             if( notif_id > NTF_MAX_NOTIF_ID )
             {

                notif_id = NTF_MIN_NOTIF_ID + 1;

             }
             s_sitos( &next_notif_id, notif_id);
             rc = obj_rep(author_ocb, author_ocd, next_notif_id,
                                                       SEG_UPDATE);
          }
          notif_id--;
          s_sitos( & next_notif_id, notif_id);
          s_pad(   & next_notif_id, next_notif_id, notif_key_length,
                                                               ' ', 'L');


          rc = add_to_user_list( author_ocb, "INDEXES.OLD_NOTIF",
                                 next_notif_id, & ( notif_ocb->oid ),
                                 0, S_NULL                         );

          ocd_drp( & author_ocd   );
          obj_cls(   author_ocb   );

       }
       else
       {
          rc = INVALID_OCB;
       }

       if ( (level == 0) || ( level == INTERACTIVE_CREATION))
       {
             /* - - - - - - - - - - - - - - - - - - - - - - - - - - - */
             /* as everything went ok there is nothing in result_str  */
             /* so put the notif_id in it so that we can display it   */
             /* on the confirmation form 1172 used in cr_ntf().       */
             /* - - - - - - - - - - - - - - - - - - - - - - - - - - - */

          s_trim( & next_notif_id, 'L' );
          s_copy(   (string *) result_str, next_notif_id, 0, 0 );

       }
       s_drop(  & next_notif_id );

    }  /* end of if for rc == 0 */
    /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     * Finally, send back to the user server the updates made to *
     * the Notif object and the users object and report the      *
     * confirmation so that server may continue its service.     *
     * Then close all objects we opened in this link routine.    *
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
    if ((level == 0) || (level == INTERACTIVE_CREATION))
    {
       t_csend(t_invoker(), rc, (string) *result_str);
       if (rc == 0)
       {
          rc = t_m_obj( t_invoker(), notif_ocb, (void **)result_str,
                                                ok_to_link, (sint)level);
          if (rc == 0)
          {
             rc = DO_NOT_CONFIRM_TRANSACTION;
          }
       }
    }
    else if((notif_ocb->type == ACT_OBJ) && (level == AUTOMATIC_CREATION))
    {
       t_csend( t_invoker(), rc, S_NULL );
    }
    if ( (!passed) && (OCB_POINTER_OK(list_ocb)) )
    {
       obj_set_flag( list_ocb, OBJ_DELETE );
       obj_cls(      list_ocb             );
    }
 } /* end of if for master server */
 else
 {

    if (notif_ocb->type == ACT_OBJ)
    {
       rc = t_remote( TM_master->MS, NOTIF_OBJ, LINK_ACT, level,
                            notif_ocb, modifier , (void **)(result_str));
       if (rc != 0)
       {
       }
    }
    else
    {
       rc = t_spawn( notif_ocb, modifier, level, (void **) result_str);
       if (rc == 0)
       {
          rc = t_waitc( TM_master->MS, NIL );
       }
    }
 }



   return(rc);

}
