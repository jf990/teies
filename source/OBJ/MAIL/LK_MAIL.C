/*+-------------------------------------------------------------------+
  |  <DOC>                                                            |
  |  <NAME>    lk_mail                                                |
  |  <AUTHOR>  John L. Foster                                         |
  |  <DATE>    August 13, 1987                                        |
  |  <LEVEL>   OBJ                                                    |
  |  <PARAM>   mail_ocb    OCB *      INPUT  Mail object control block|
  |  <PARAM>   packet      string     INPUT  Packet of OCD's that are |
  |                                           modified for reiterative|
  |                                           calls from cr/md_mail().|
  |  <PARAM>   level       hword      INPUT  State level modifier     |
  |  <PARAM>   result_str  string *   INOUT  Pointer to a string where|
  |                                           error messages and other|
  |                                           communicated data will  |
  |                                           go.                     |
  |  <PURPOSE> Link the new mail object to the following:             |
  |              1) Authors Old Mail index;                           |
  |              2) Recipients New Mail indexes;                      |
  |              3) keyword index                                     |
  |              4) date/time index                                   |
  |              4) Contents object                                   |
  |            First the recipient names must be checked at the MS    |
  |            to verify they are all valid.                          |
  |                                                                   |
  |            If level = 0 then the object is thought to be a new    |
  |            object, otherwise this link routine will think it is   |
  |            an existing object and attempt to de-index any existing|
  |            link that is to be changed before establishing the new |
  |            link.                                                  |
  |                                                                   |
  |            If this server is not the Master Server then the object|
  |            is sent to the Master Server for linking.  The MS will |
  |            send back the entire mail object when done.  If errors |
  |            occur the confirmation packet will contain the error   |
  |            code and any resulting data string to report to the    |
  |            user.                                                  |
  |                                                                   |
  |  <OUTPUT>  sint      result code either generated by this routine |
  |                      locally or remotely.                         |
  |  <LIMITS>                                                         |
  |            If the user sends the mail to him/herself or a user    |
  |            appears on the To: list more than once, the linking of |
  |            the new mail will close that user's object and we loose|
  |            it for further operations.  Therefore special checking |
  |            must be included to assure we can reopen these objects |
  |            when needed.                                           |
  |  </DOC>                                                           |
  +-------------------------------------------------------------------+*/
#include "defs.h"
#include "str.h"
#include "osk.h"
#include "debug.h"
#include "isv.h"
#include "obj.h"
#include "obj_prim.h"
#include "exc.h"
#include "tm.h"
#include "activity.h"



sint     lk_mail( mail_ocb, packet, level, result_str )

OCB              *mail_ocb;
string            packet;
hword             level;
string           *result_str;

{

   sint   rc                =        0,
          num_of_recipients =        0,
          amount            =        0,
          waiting           =        0,
          position          =        0,
          state             =        0,
          reply_id          =        0;
   hword  command           = OCD_SEND,
          flags             =        0;
   string
          item_id           =   S_NULL,
          target            =   S_NULL,
          author            =   S_NULL,
          work_str          =   S_NULL,
          activity_key      =   S_NULL,
          blank             =   S_NULL,
          to                =   S_NULL,
          to_prefix         =   S_NULL,
          key_words         =   S_NULL,
          invoker           =   S_NULL,
          server            =   S_NULL;
   OCD   *mail_ocd          =      NIL,
         *ocd               =      NIL;

   boolean   ok_to_link     =    FALSE,
             activity_attached = FALSE;
   byte      replying       =    FALSE;
   OCB    *  contents       =      NIL;
   OID                    contents_oid,
                            author_oid;
   datetime                         dt;
   ISCF_TAB *conn_table_entry =    NIL;






if( TM_master->usrtype == MASTER_SERVER )
{

      string   names          = S_NULL,
               bad_names      = S_NULL,
               separator      = S_NULL,
               dot            = S_NULL,
               comma          = S_NULL,
               mail_id        = S_NULL,
               mail_id_suffix = S_NULL,
               mail_index_key = S_NULL,
               parser         = S_NULL;

      OCB     *psi_ocb        =    NIL,
              *smi_ocb        =    NIL,
              *root_ocb       =    NIL,
              *author_ocb     =    NIL;
      OCD     *recipient_ocd  =    NIL,
              *author_ocd     =    NIL;
      OID      root_oid               ,
               act_oid                ,
              *name_oid       =    NIL,
             **user_oid_array =    NIL;
      sint     i              =      0,
               new_mail_id    =      0,
               errors         =      0;
      hword    mailtype       =      0,
               level_act      = ACT_LINK_MAIL,
               smi_flags      =      0;

                        /* - - - - - - - - - - - - - - - - - - - - - -*
                         |   The first step is to validate all the    |
                         |   intended recipients.  Use s_parse() to   |
                         |   get each name from the string of names   |
                         |   entered by the user.  Then find these    |
                         |   users in the database.  All users not    |
                         |   found are collected together.  If there  |
                         |   are unknown users then put this process  |
                         |   on hold by keeping the object here and   |
                         |   wait for the user server to either send  |
                         |   updates or request the process be canned.|
                         + - - - - - - - - - - - - - - - - - - - - - -*/


   s_init( & separator, "; "      );
   s_init( & comma,     ", "      );
   s_init( & dot,       "."       );

   ocd_new( & mail_ocd,  "MESSAGE.REPLY"             );
   obj_get(   mail_ocb,   mail_ocd,       & replying );
   s_init(  &(mail_ocd->name), "MESSAGE.TO"          );
   obj_get(   mail_ocb,   mail_ocd,       & target   );


   flags = 0;
   rc = t_valnam( target, &user_oid_array, &amount, &bad_names, flags );

   if(  rc != 0  )
   {

      if( result_str != NIL )
      {

         s_copy( result_str, bad_names, 0, 0 );
         s_drop( & bad_names );

      }

     /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
      |                                                               |
      |  There were errors the user server must resolve.  Send back   |
      |  what we know and cancel this task.  We will keep the object  |
      |  on this server unless the user server signs off without      |
      |  resolving the problem.  Then we will have the temporary      |
      |  object handy if the user server decides to send us a correct |
      |  version.  Note they will only have to send any corrected OCDs|
      |  and we can start the whole process over and avoid the        |
      |  resending of the whole object.                               |
      |                                                               |
      + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +*/
   }
   else
   {

      num_of_recipients = amount;

      if( (level != LINK_MODIFIED_MAIL) && replying )
      {


        /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         |  A reply requires us to get all the original recipient links|
         |  and use those as the primary addresses for the reply, and  |
         |  add the root author as the first address.  Then copy only  |
         |  addresses that were resolved above from the TO line if they|
         |  already have not occured.  The resulting list of OID's are |
         |  all the users that will get this new piece of mail. Also   |
         |  verify and link the root as the owning object to this one. |
         |                                                             |
         |  Also - establish forward and reverse links with the reply  |
         |  item and force the Owner to the Root (replyed to) item.    |
         |                                                             |
         |  We can determine the mail id suffix based on the number of |
         |  replys the root has.                                       |
         * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
      /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
       | In order to format the Mail Id, we use the following rules:   |
       |=> A new root ID comes from the SMI NEXT_AVAILABLE component.  |
       |     To get this we call SMI_QRY().                            |
       |=> A reply to a root requires  us to get the count of replies  |
       |     already associated to that root and use that counter.  A  |
       |     reply will then be prefixed with the Root Mail id, such as|
       |     M 42.3 (third reply to root 42).                          |
       + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

         obj_find( mail_ocb, "%LINKS.OWNER", & root_oid );
         root_ocb = obj_opn( & root_oid, OBJ_UPDATE );
         if( OCB_POINTER_OK( root_ocb ) )
         {

            OID   **recipient_oid_array      =  NIL;
            sint    recipient_oid_array_size =    0,
                    limit                    =    0,
                    mflags                   =    0;


            obj_find(   root_ocb, "MESSAGE.REPLY_COUNT",    & reply_id );
            reply_id ++ ;
            obj_update( root_ocb, "MESSAGE.REPLY_COUNT",    & reply_id );
            s_sitos(  & mail_id_suffix, reply_id );
            obj_update( mail_ocb, "MESSAGE.REPLY_ID", & mail_id_suffix );
            s_cat(    & mail_id_suffix, dot, mail_id_suffix,      0, 0 );
            obj_find(   root_ocb, "MESSAGE.ID",             & work_str );
            obj_update( mail_ocb, "MESSAGE.ROOT_ID",          work_str );
            s_cat(    & item_id, work_str, mail_id_suffix,        0, 0 );
            obj_cls( root_ocb );

         }
         else
         {

            replying = FALSE;

         }
      }

      if( level != LINK_MODIFIED_MAIL )
      {

         if( ! replying )
         {

            smi_flags   = MAIL_ITEM_ROOT;
            new_mail_id = smi_qry(  MAIL_ITEM_NEXT  );
            if( new_mail_id < 0 )
            {

               new_mail_id = 0 ;

            }
            new_mail_id ++ ;
            s_sitos( & item_id, new_mail_id );

         }

         /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
          * Update the System Mail Index with this Mail ID and Label  *
          * for global mail searches.                                 *
          * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

         rc = smi_add( & ( mail_ocb->oid ), item_id, S_NULL, smi_flags );
         obj_update( mail_ocb, "MESSAGE.ID", item_id );

      }

     /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
      |                                                               |
      | Now format the author's user id so at render time we do not   |
      | have to request that and slow down the system.                |
      |                                                               |
      + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

      invoker = t_invoker();
      if( s_len( invoker ) > 0 )
      {

         conn_table_entry = t_conn(  invoker  );
         author_ocb = obj_opn(
                            & ( conn_table_entry->objectID ) , OBJ_UPDATE
                             );
         os_memc( &( author_ocb->oid ),  & author_oid, sizeof( OID ) );

      }
      else
      {

          author_ocb = NIL;

      }

      os_dttm(  & dt  );
      obj_update( mail_ocb, "%SYSTEM.CREATE_DATE", & dt );

      obj_find( mail_ocb, "MESSAGE.KEYS", & key_words );
      rc = t_ckkeys( & work_str, key_words );
      if( rc == 0 )
      {

         obj_update( mail_ocb, "MESSAGE.KEYS", work_str );

      }
      os_memn( & act_oid, sizeof( OID ) );
      obj_find(  mail_ocb, "MESSAGE.ACTIVITY", & act_oid );
      if( ! OID_IS_NULL ( & act_oid ) )
      {


         activity_attached = TRUE;
         rc = lk_act( mail_ocb, packet, level_act, result_str );

      }

         /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
          * Link the Mail to each recipients mail box and maintain    *
          * their associated counters.                                *
          * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


      s_init(  & mail_index_key,    "ttDateTime"           );
      os_memc( & mailtype, s_buffer( mail_index_key ),   2 );
      os_memc( & dt,       s_buffer( mail_index_key )+2, 8 );

      if( activity_attached )
      {

         s_alloc( & activity_key,    sizeof( OID ) );
         s_smp_ul(  activity_key ) = sizeof( OID )  ;
         os_memc( & act_oid, s_buffer( activity_key ), sizeof( OID ) );

      }

      for( i=1; i<=num_of_recipients; i++ )
      {

         OCB  *recipient_ocb = NIL,
              *ocb           = NIL;
         byte *mailbox       = NIL;
         OID   oid_of_mail        ;


         recipient_ocb = obj_opn( *(user_oid_array + i), OBJ_UPDATE );

         if( OCB_POINTER_OK( recipient_ocb ) )
         {

            rc = add_to_user_list( recipient_ocb, "INDEXES.MAILBOX",
                                   mail_index_key, &(mail_ocb->oid),
                                   0, S_NULL                           );

            rc = gt_name( recipient_ocb, S_NULL, NICKNAME_ONLY,
                                                            & work_str );
            if( rc == 0 )
            {

               s_cat( & to, to, work_str, 0, 0 );
               s_cat( & to, to, comma,    0, 0 );

            }
            rc = obj_alk ( mail_ocb,      "ACCESS",
                            recipient_ocb, RECIPIENT_LINK );


            if (  activity_attached  )
            {

              rc = add_to_user_list( recipient_ocb, "INDEXES.UNDONE_ACT",
                                     activity_key, & act_oid, 0, S_NULL);

            }
            obj_cls( recipient_ocb );
            os_memd( *(user_oid_array + i) );

         }
         else
         {

            errors ++ ;

         }
      }

      s_smp_ul( to ) = s_len( to ) - s_len( comma ) ;
      obj_update( mail_ocb, "MESSAGE.TO", to );


      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
       * Link mail to author's old mailbox, increment count            *
       * Link to author's keyword index, authored index                *
       * Link to the System Mail ID Index                              *
       * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

      os_memc( & (mail_ocb->oid), s_buffer( mail_index_key )+2, 8 );
      rc = add_to_user_list( author_ocb, "INDEXES.OLD_MAIL",
                             mail_index_key, & (mail_ocb->oid),
                             0, S_NULL                            );

      /* If author send mail to himself, DO NOT put it in the OLD
         mail box.                                                    */


      if (  activity_attached  )
      {

         s_init( & (author_ocd->name), "INDEXES.ACTIVITIES.OID" );
         rc = obj_rep( author_ocb, author_ocd, & act_oid, SEG_UPDATE );
         s_drop( & activity_key );

      }
      ocd_new ( & ocd, "MESSAGE.CONTENTS" );
      rc = obj_get( mail_ocb, ocd,     & contents_oid );
      if( rc == 0  && ( ! OID_IS_NULL( & contents_oid ) )  )
      {

         contents = obj_opn( & contents_oid, OBJ_UPDATE );
         if( OCB_POINTER_OK( contents ) )
         {

            obj_update( contents, "%LINKS.OWNER", & mail_ocb->oid );
            obj_cls(    contents );

         }
      }

      rc = t_increment_items_created( conn_table_entry );

      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
       * Finally, send back to the user server the updates made to *
       * the mail object and the users object and report the       *
       * confirmation so that server may continue its service.     *
       *                                                           *
       * Then close all objects we opened in this link routine.    *
       *                                                           *
       * Also - since we send back the completed Mail object here  *
       * as the transaction confirmation, make sure the calling lo-*
       * gic does not send an additional confirmation to the re-   *
       * questing server.                                          *
       * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

      state = (sint) level;
      rc = t_m_obj( t_invoker(), mail_ocb, result_str, ok_to_link, state );
      if( rc == 0 )
      {

         rc = DO_NOT_CONFIRM_TRANSACTION;

      }

      obj_cls(      author_ocb          );
      obj_set_mode( mail_ocb, OBJ_FLUSH );
      obj_cls(      mail_ocb            );

   }

   s_drop(  & separator      );
   s_drop(  & comma          );
   s_drop(  & dot            );
   s_drop(  & to             );
   s_drop(  & key_words      );
   s_drop(  & mail_index_key );
   s_drop(  & item_id        );
   s_drop(  & work_str       );
   s_drop(  & target         );
   os_memd(   user_oid_array );
   ocd_drp( & mail_ocd       );
   ocd_drp( & recipient_ocd  );
   ocd_drp( & author_ocd     );

}
else
{

   rc = obj_find( mail_ocb, "MESSAGE.CONTENTS", & contents_oid );
   if( rc == 0  && ( ! OID_IS_NULL( & contents_oid ) )  )
   {

      contents = obj_opn( & contents_oid, OBJ_READ );
      if( OCB_POINTER_OK( contents ) )
      {

         ok_to_link = FALSE;
         rc = t_m_obj( TM_master->MS, contents, result_str,
                                                     ok_to_link, state );
         if( rc == 0 )
         {

            obj_set_mode( contents, OBJ_REMOTE );
            obj_cls(      contents );

         }
      }
   }

   rc = t_spawn( mail_ocb, packet, (sint) level, result_str );

}



   return(rc);

}
